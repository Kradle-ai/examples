SAMPLE_INIT_DATA = {
    "participantId": "python1",
    "runId": "21b3f581-1447-465a-b6cc-f9f97654b9f9",
    "sessionId": "21b3f581-1447-465a-b6cc-f9f97654b9f9",
    "observationId": "ezode9hknwejtitx1ikv",
    "agent_modes": {
        "self_preservation": True,
        "unstuck": False,
        "cowardice": False, 
        "self_defense": False,
        "hunting": False,
        "item_collecting": False,
        "torch_placing": False,
        "elbow_room": False,
        "idle_staring": False,
        "cheat": False,
        "mcmode": "survival"
    },
    "task": "Goal:\nSurvive a Zombie Attack. First, construct a small protective shelter or enclosure within 60 seconds. Then, survive a 60-second zombie attack.",
    "available_events": [
        "interval",
        "initial_state", 
        "command_executed",
        "chat",
        "message",
        "health",
        "damage", 
        "death",
        "game_over",
        "idle"
    ],
    "js_functions": {'skills': {'activateNearestBlock': {'description': 'function activateNearestBlock(bot, type) {\n    return __awaiter(this, void 0, void 0, function* () {\n        /**\n         * Activate the nearest block of the given type.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {string} type, the type of block to activate.\n         * @returns {Promise<boolean>} true if the block was activated, false otherwise.\n         * @example\n         * await skills.activateNearestBlock(bot, "lever");\n         * **/\n        let block = world.getNearestBlock(bot, type, 16);\n        if (!block) {\n            log(bot, `Could not find any ${type} to activate.`);\n            return false;\n        }\n        if (bot.entity.position.distanceTo(block.position) > 4.5) {\n            let pos = block.position;\n            bot.pathfinder.setMovements(new pf.Movements(bot));\n            yield bot.pathfinder.goto(new pf.goals.GoalNear(pos.x, pos.y, pos.z, 4));\n        }\n        yield bot.activateBlock(block);\n        log(bot, `Activated ${type} at x:${block.position.x.toFixed(1)}, y:${block.position.y.toFixed(1)}, z:${block.position.z.toFixed(1)}.`);\n        return true;\n    });\n}'}, 'attackEntity': {'description': 'function attackEntity(bot_1, entity_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, entity, kill = true) {\n        /**\n         * Attack mob of the given type.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {Entity} entity, the entity to attack.\n         * @returns {Promise<boolean>} true if the entity was attacked, false if interrupted\n         * @example\n         * await skills.attackEntity(bot, entity);\n         **/\n        //TODO : type check entity + all the other functions.\n        let pos = entity.position;\n        if (!pos) {\n            log(bot, "Entity not found.");\n            return false;\n        }\n        yield equipHighestAttack(bot);\n        if (!kill) {\n            if (bot.entity.position.distanceTo(pos) > 5) {\n                console.log("moving to mob...");\n                yield goToPosition(bot, pos.x, pos.y, pos.z);\n            }\n            console.log("attacking mob...");\n            yield bot.attack(entity);\n        }\n        else {\n            bot.pvp.attack(entity);\n            while (world.getNearbyEntities(bot, 24).includes(entity)) {\n                yield new Promise((resolve) => setTimeout(resolve, 1000));\n                if (bot.interrupt_code) {\n                    bot.pvp.stop();\n                    return false;\n                }\n            }\n            log(bot, `Successfully killed ${entity.name}.`);\n            yield pickupNearbyItems(bot);\n            return true;\n        }\n    });\n}'}, 'attackNearest': {'description': 'function attackNearest(bot_1, mobType_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, mobType, kill = true) {\n        /**\n         * Attack mob of the given type.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {string} mobType, the type of mob to attack.\n         * @param {boolean} kill, whether or not to continue attacking until the mob is dead. Defaults to true.\n         * @returns {Promise<boolean>} true if the mob was attacked, false if the mob type was not found.\n         * @example\n         * await skills.attackNearest(bot, "zombie", true);\n         **/\n        bot.modes.pause("cowardice");\n        if (mobType === "drowned" ||\n            mobType === "cod" ||\n            mobType === "salmon" ||\n            mobType === "tropical_fish" ||\n            mobType === "squid")\n            bot.modes.pause("self_preservation"); // so it can go underwater. TODO: have an drowning mode so we don\'t turn off all self_preservation\n        const mob = world\n            .getNearbyEntities(bot, 24)\n            .find((entity) => entity.name === mobType);\n        if (mob) {\n            return yield attackEntity(bot, mob, kill);\n        }\n        log(bot, "Could not find any " + mobType + " to attack.");\n        return false;\n    });\n}'}, 'avoidEnemies': {'description': 'function avoidEnemies(bot_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, distance = 16) {\n        /**\n         * Move a given distance away from all nearby enemy mobs.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {number} distance, the distance to move away.\n         * @returns {Promise<boolean>} true if the bot moved away, false otherwise.\n         * @example\n         * await skills.avoidEnemies(bot, 8);\n         **/\n        bot.modes.pause("self_preservation"); // prevents damage-on-low-health from interrupting the bot\n        let enemy = world.getNearestEntityWhere(bot, (entity) => mc.isHostile(entity), distance);\n        while (enemy) {\n            const follow = new pf.goals.GoalFollow(enemy, distance + 1); // move a little further away\n            const inverted_goal = new pf.goals.GoalInvert(follow);\n            bot.pathfinder.setMovements(new pf.Movements(bot));\n            bot.pathfinder.setGoal(inverted_goal, true);\n            yield new Promise((resolve) => setTimeout(resolve, 500));\n            enemy = world.getNearestEntityWhere(bot, (entity) => mc.isHostile(entity), distance);\n            if (bot.interrupt_code) {\n                break;\n            }\n            if (enemy && bot.entity.position.distanceTo(enemy.position) < 3) {\n                yield attackEntity(bot, enemy, false);\n            }\n        }\n        bot.pathfinder.stop();\n        log(bot, `Moved ${distance} away from enemies.`);\n        return true;\n    });\n}'}, 'breakBlockAt': {'description': 'function breakBlockAt(bot, x, y, z) {\n    return __awaiter(this, void 0, void 0, function* () {\n        /**\n         * Break the block at the given position. Will use the bot\'s equipped item.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {number} x, the x coordinate of the block to break.\n         * @param {number} y, the y coordinate of the block to break.\n         * @param {number} z, the z coordinate of the block to break.\n         * @returns {Promise<boolean>} true if the block was broken, false otherwise.\n         * @example\n         * let position = world.getPosition(bot);\n         * await skills.breakBlockAt(bot, position.x, position.y - 1, position.x);\n         **/\n        if (x == null || y == null || z == null)\n            throw new Error("Invalid position to break block at.");\n        let block = bot.blockAt(new Vec3(x, y, z));\n        if (block.name !== "air" && block.name !== "water" && block.name !== "lava") {\n            console.log("which mode is on?", bot.modes.isOn("cheat"));\n            if (bot.modes.isOn("cheat")) {\n                let msg = "/setblock " +\n                    Math.floor(x) +\n                    " " +\n                    Math.floor(y) +\n                    " " +\n                    Math.floor(z) +\n                    " air";\n                bot.chat(msg);\n                log(bot, `Used /setblock to break block at ${x}, ${y}, ${z}.`);\n                return true;\n            }\n            if (bot.entity.position.distanceTo(block.position) > 4.5) {\n                let pos = block.position;\n                let movements = new pf.Movements(bot);\n                //movements.canPlaceOn = false; // TODO: fix this\n                movements.allow1by1towers = false;\n                bot.pathfinder.setMovements(movements);\n                yield bot.pathfinder.goto(new pf.goals.GoalNear(pos.x, pos.y, pos.z, 4));\n            }\n            if (bot.game.gameMode !== "creative") {\n                yield bot.tool.equipForBlock(block);\n                const itemId = bot.heldItem ? bot.heldItem.type : null;\n                if (!block.canHarvest(itemId)) {\n                    log(bot, `Don\'t have right tools to break ${block.name}.`);\n                    return false;\n                }\n            }\n            yield bot.dig(block, true);\n            log(bot, `Broke ${block.name} at x:${x.toFixed(1)}, y:${y.toFixed(1)}, z:${z.toFixed(1)}.`);\n        }\n        else {\n            log(bot, `Skipping block at x:${x.toFixed(1)}, y:${y.toFixed(1)}, z:${z.toFixed(1)} because it is ${block.name}.`);\n            return false;\n        }\n        return true;\n    });\n}'}, 'clearNearestFurnace': {'description': 'function clearNearestFurnace(bot) {\n    return __awaiter(this, void 0, void 0, function* () {\n        /**\n         * Clears the nearest furnace of all items.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @returns {Promise<boolean>} true if the furnace was cleared, false otherwise.\n         * @example\n         * await skills.clearNearestFurnace(bot);\n         **/\n        let furnaceBlock = world.getNearestBlock(bot, "furnace", 32);\n        if (!furnaceBlock) {\n            log(bot, `No furnace nearby to clear.`);\n            return false;\n        }\n        if (bot.entity.position.distanceTo(furnaceBlock.position) > 4) {\n            yield goToNearestBlock(bot, "furnace", 4, 32);\n        }\n        console.log("clearing furnace...");\n        const furnace = yield bot.openFurnace(furnaceBlock);\n        console.log("opened furnace...");\n        // take the items out of the furnace\n        let smelted_item, intput_item, fuel_item;\n        if (furnace.outputItem())\n            smelted_item = yield furnace.takeOutput();\n        if (furnace.inputItem())\n            intput_item = yield furnace.takeInput();\n        if (furnace.fuelItem())\n            fuel_item = yield furnace.takeFuel();\n        console.log(smelted_item, intput_item, fuel_item);\n        let smelted_name = smelted_item\n            ? `${smelted_item.count} ${smelted_item.name}`\n            : `0 smelted items`;\n        let input_name = intput_item\n            ? `${intput_item.count} ${intput_item.name}`\n            : `0 input items`;\n        let fuel_name = fuel_item\n            ? `${fuel_item.count} ${fuel_item.name}`\n            : `0 fuel items`;\n        log(bot, `Cleared furnace, received ${smelted_name}, ${input_name}, and ${fuel_name}.`);\n        return true;\n    });\n}'}, 'collectBlock': {'description': 'function collectBlock(bot_1, blockType_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, blockType, num = 1, exclude = null) {\n        /**\n         * Collect one of the given block type.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {string} blockType, the type of block to collect.\n         * @param {number} num, the number of blocks to collect. Defaults to 1.\n         * @returns {Promise<boolean>} true if the block was collected, false if the block type was not found.\n         * @example\n         * await skills.collectBlock(bot, "oak_log");\n         **/\n        if (num < 1) {\n            log(bot, `Invalid number of blocks to collect: ${num}.`);\n            return false;\n        }\n        let blocktypes = [blockType];\n        if (blockType === "coal" ||\n            blockType === "diamond" ||\n            blockType === "emerald" ||\n            blockType === "iron" ||\n            blockType === "gold" ||\n            blockType === "lapis_lazuli" ||\n            blockType === "redstone")\n            blocktypes.push(blockType + "_ore");\n        if (blockType.endsWith("ore"))\n            blocktypes.push("deepslate_" + blockType);\n        if (blockType === "dirt")\n            blocktypes.push("grass_block");\n        let collected = 0;\n        for (let i = 0; i < num; i++) {\n            let blocks = world.getNearestBlocks(bot, blocktypes, 64);\n            if (exclude) {\n                for (let position of exclude) {\n                    blocks = blocks.filter((block) => block.position.x !== position.x ||\n                        block.position.y !== position.y ||\n                        block.position.z !== position.z);\n                }\n            }\n            const movements = new pf.Movements(bot);\n            movements.dontMineUnderFallingBlock = false;\n            blocks = blocks.filter((block) => movements.safeToBreak(block));\n            if (blocks.length === 0) {\n                if (collected === 0)\n                    log(bot, `No ${blockType} nearby to collect.`);\n                else\n                    log(bot, `No more ${blockType} nearby to collect.`);\n                break;\n            }\n            const block = blocks[0];\n            yield bot.tool.equipForBlock(block);\n            const itemId = bot.heldItem ? bot.heldItem.type : null;\n            if (!block.canHarvest(itemId)) {\n                log(bot, `Don\'t have right tools to harvest ${blockType}.`);\n                return false;\n            }\n            try {\n                yield bot.collectBlock.collect(block);\n                collected++;\n                yield autoLight(bot);\n            }\n            catch (err) {\n                if (err.name === "NoChests") {\n                    log(bot, `Failed to collect ${blockType}: Inventory full, no place to deposit.`);\n                    break;\n                }\n                else {\n                    log(bot, `Failed to collect ${blockType}: ${err}.`);\n                    continue;\n                }\n            }\n            if (bot.interrupt_code)\n                break;\n        }\n        log(bot, `Collected ${collected} ${blockType}.`);\n        return collected > 0;\n    });\n}'}, 'consume': {'description': 'function consume(bot_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, itemName = "") {\n        /**\n         * Eat/drink the given item.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {string} itemName, the item to eat/drink.\n         * @returns {Promise<boolean>} true if the item was eaten, false otherwise.\n         * @example\n         * await skills.eat(bot, "apple");\n         **/\n        let item, name;\n        if (itemName) {\n            item = bot.inventory.items().find((item) => item.name === itemName);\n            name = itemName;\n        }\n        if (!item) {\n            log(bot, `You do not have any ${name} to eat.`);\n            return false;\n        }\n        yield bot.equip(item, "hand");\n        yield bot.consume();\n        log(bot, `Consumed ${item.name}.`);\n        return true;\n    });\n}'}, 'craftRecipe': {'description': 'function craftRecipe(bot_1, itemName_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, itemName, num = 1) {\n        /**\n         * Attempt to craft the given item name from a recipe. May craft many items.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {string} itemName, the item name to craft.\n         * @returns {Promise<boolean>} true if the recipe was crafted, false otherwise.\n         * @example\n         * await skills.craftRecipe(bot, "stick");\n         **/\n        let placedTable = false;\n        const _recipes = mc.getItemCraftingRecipes(itemName);\n        if (!_recipes || _recipes.length == 0) {\n            log(bot, `${itemName} is either not an item, or it does not have a crafting recipe!`);\n            return false;\n        }\n        // get recipes that don\'t require a crafting table\n        let recipes = bot.recipesFor(mc.getItemId(itemName), null, 1, null);\n        let craftingTable = null;\n        const craftingTableRange = 32;\n        placeTable: if (!recipes || recipes.length === 0) {\n            recipes = bot.recipesFor(mc.getItemId(itemName), null, 1, true);\n            if (!recipes || recipes.length === 0)\n                break placeTable; //Don\'t bother going to the table if we don\'t have the required resources.\n            // Look for crafting table\n            craftingTable = world.getNearestBlock(bot, "crafting_table", craftingTableRange);\n            if (craftingTable === null) {\n                // Try to place crafting table\n                let hasTable = world.getInventoryCounts(bot)["crafting_table"] > 0;\n                if (hasTable) {\n                    let pos = world.getNearestFreeSpace(bot, 1, 6);\n                    yield placeBlock(bot, "crafting_table", pos.x, pos.y, pos.z);\n                    craftingTable = world.getNearestBlock(bot, "crafting_table", craftingTableRange);\n                    if (craftingTable) {\n                        recipes = bot.recipesFor(mc.getItemId(itemName), null, 1, craftingTable);\n                        placedTable = true;\n                    }\n                }\n                else {\n                    log(bot, `Crafting ${itemName} requires a crafting table.`);\n                    return false;\n                }\n            }\n            else {\n                recipes = bot.recipesFor(mc.getItemId(itemName), null, 1, craftingTable);\n            }\n        }\n        if (!recipes || recipes.length === 0) {\n            log(bot, `You do not have the resources to craft a ${itemName}. It requires: ${Object.entries(_recipes[0])\n                .map(([key, value]) => `${key}: ${value}`)\n                .join(", ")}.`);\n            if (placedTable) {\n                yield collectBlock(bot, "crafting_table", 1);\n            }\n            return false;\n        }\n        if (craftingTable &&\n            bot.entity.position.distanceTo(craftingTable.position) > 4) {\n            yield goToNearestBlock(bot, "crafting_table", 4, craftingTableRange);\n        }\n        const recipe = recipes[0];\n        console.log("crafting...");\n        //Check that the agent has sufficient items to use the recipe `num` times.\n        const inventory = world.getInventoryCounts(bot); //Items in the agents inventory\n        const requiredIngredients = mc.ingredientsFromPrismarineRecipe(recipe); //Items required to use the recipe once.\n        const craftLimit = mc.calculateLimitingResource(inventory, requiredIngredients);\n        yield bot.craft(recipe, Math.min(craftLimit.num, num), craftingTable);\n        if (craftLimit.num < num)\n            log(bot, `Not enough ${craftLimit.limitingResource} to craft ${num}, crafted ${craftLimit.num}. You now have ${world.getInventoryCounts(bot)[itemName]} ${itemName}.`);\n        else\n            log(bot, `Successfully crafted ${itemName}, you now have ${world.getInventoryCounts(bot)[itemName]} ${itemName}.`);\n        if (placedTable) {\n            yield collectBlock(bot, "crafting_table", 1);\n        }\n        //Equip any armor the bot may have crafted.\n        //There is probablly a more efficient method than checking the entire inventory but this is all mineflayer-armor-manager provides. :P\n        bot.armorManager.equipAll();\n        return true;\n    });\n}'}, 'defendSelf': {'description': 'function defendSelf(bot_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, range = 9) {\n        /**\n         * Defend yourself from all nearby hostile mobs until there are no more.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {number} range, the range to look for mobs. Defaults to 8.\n         * @returns {Promise<boolean>} true if the bot found any enemies and has killed them, false if no entities were found.\n         * @example\n         * await skills.defendSelf(bot);\n         * **/\n        bot.modes.pause("self_defense");\n        bot.modes.pause("cowardice");\n        let attacked = false;\n        let enemy = world.getNearestEntityWhere(bot, (entity) => mc.isHostile(entity), range);\n        while (enemy) {\n            yield equipHighestAttack(bot);\n            if (bot.entity.position.distanceTo(enemy.position) >= 4 &&\n                enemy.name !== "creeper" &&\n                enemy.name !== "phantom") {\n                try {\n                    bot.pathfinder.setMovements(new pf.Movements(bot));\n                    yield bot.pathfinder.goto(new pf.goals.GoalFollow(enemy, 3.5), true);\n                }\n                catch (err) {\n                    /* might error if entity dies, ignore */\n                }\n            }\n            if (bot.entity.position.distanceTo(enemy.position) <= 2) {\n                try {\n                    bot.pathfinder.setMovements(new pf.Movements(bot));\n                    let inverted_goal = new pf.goals.GoalInvert(new pf.goals.GoalFollow(enemy, 2));\n                    yield bot.pathfinder.goto(inverted_goal, true);\n                }\n                catch (err) {\n                    /* might error if entity dies, ignore */\n                }\n            }\n            bot.pvp.attack(enemy);\n            attacked = true;\n            yield new Promise((resolve) => setTimeout(resolve, 500));\n            enemy = world.getNearestEntityWhere(bot, (entity) => mc.isHostile(entity), range);\n            if (bot.interrupt_code) {\n                bot.pvp.stop();\n                return false;\n            }\n        }\n        bot.pvp.stop();\n        if (attacked)\n            log(bot, `Successfully defended self.`);\n        else\n            log(bot, `No enemies nearby to defend self from.`);\n        return attacked;\n    });\n}'}, 'discard': {'description': 'function discard(bot_1, itemName_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, itemName, num = -1) {\n        /**\n         * Discard the given item.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {string} itemName, the item or block name to discard.\n         * @param {number} num, the number of items to discard. Defaults to -1, which discards all items.\n         * @returns {Promise<boolean>} true if the item was discarded, false otherwise.\n         * @example\n         * await skills.discard(bot, "oak_log");\n         **/\n        let discarded = 0;\n        while (true) {\n            let item = bot.inventory\n                .items()\n                .find((item) => item.name === itemName);\n            if (!item) {\n                break;\n            }\n            let to_discard = num === -1 ? item.count : Math.min(num - discarded, item.count);\n            yield bot.toss(item.type, null, to_discard);\n            discarded += to_discard;\n            if (num !== -1 && discarded >= num) {\n                break;\n            }\n        }\n        if (discarded === 0) {\n            log(bot, `You do not have any ${itemName} to discard.`);\n            return false;\n        }\n        log(bot, `Discarded ${discarded} ${itemName}.`);\n        return true;\n    });\n}'}, 'equip': {'description': 'function equip(bot, itemName) {\n    return __awaiter(this, void 0, void 0, function* () {\n        /**\n         * Equip the given item to the proper body part, like tools or armor.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {string} itemName, the item or block name to equip.\n         * @returns {Promise<boolean>} true if the item was equipped, false otherwise.\n         * @example\n         * await skills.equip(bot, "iron_pickaxe");\n         **/\n        let item = bot.inventory.slots.find((slot) => slot && slot.name === itemName);\n        if (!item) {\n            log(bot, `You do not have any ${itemName} to equip.`);\n            return false;\n        }\n        if (itemName.includes("leggings")) {\n            yield bot.equip(item, "legs");\n        }\n        else if (itemName.includes("boots")) {\n            yield bot.equip(item, "feet");\n        }\n        else if (itemName.includes("helmet")) {\n            yield bot.equip(item, "head");\n        }\n        else if (itemName.includes("chestplate") || itemName.includes("elytra")) {\n            yield bot.equip(item, "torso");\n        }\n        else if (itemName.includes("shield")) {\n            yield bot.equip(item, "off-hand");\n        }\n        else {\n            yield bot.equip(item, "hand");\n        }\n        log(bot, `Equipped ${itemName}.`);\n        return true;\n    });\n}'}, 'followPlayer': {'description': 'function followPlayer(bot_1, username_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, username, distance = 4) {\n        /**\n         * Follow the given player endlessly. Will not return until the code is manually stopped.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {string} username, the username of the player to follow.\n         * @returns {Promise<boolean>} true if the player was found, false otherwise.\n         * @example\n         * await skills.followPlayer(bot, "player");\n         **/\n        let player = bot.players[username].entity;\n        if (!player)\n            return false;\n        const move = new pf.Movements(bot);\n        bot.pathfinder.setMovements(move);\n        bot.pathfinder.setGoal(new pf.goals.GoalFollow(player, distance), true);\n        log(bot, `You are now actively following player ${username}.`);\n        while (!bot.interrupt_code) {\n            yield new Promise((resolve) => setTimeout(resolve, 500));\n            // in cheat mode, if the distance is too far, teleport to the player\n            if (bot.modes.isOn("cheat") &&\n                bot.entity.position.distanceTo(player.position) > 100 &&\n                player.isOnGround) {\n                yield goToPlayer(bot, username);\n            }\n            if (bot.modes.isOn("unstuck")) {\n                const is_nearby = bot.entity.position.distanceTo(player.position) <= distance + 1;\n                if (is_nearby)\n                    bot.modes.pause("unstuck");\n                else\n                    bot.modes.unpause("unstuck");\n            }\n        }\n        return true;\n    });\n}'}, 'giveToPlayer': {'description': 'function giveToPlayer(bot_1, itemType_1, username_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, itemType, username, num = 1) {\n        /**\n         * Give one of the specified item to the specified player\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {string} itemType, the name of the item to give.\n         * @param {string} username, the username of the player to give the item to.\n         * @param {number} num, the number of items to give. Defaults to 1.\n         * @returns {Promise<boolean>} true if the item was given, false otherwise.\n         * @example\n         * await skills.giveToPlayer(bot, "oak_log", "player1");\n         **/\n        let player = bot.players[username].entity;\n        if (!player) {\n            log(bot, `Could not find ${username}.`);\n            return false;\n        }\n        yield goToPlayer(bot, username, 3);\n        // if we are 2 below the player\n        log(bot, bot.entity.position.y + player.position.y);\n        if (bot.entity.position.y < player.position.y - 1) {\n            yield goToPlayer(bot, username, 1);\n        }\n        // if we are too close, make some distance\n        if (bot.entity.position.distanceTo(player.position) < 2) {\n            yield moveAwayFromEntity(bot, player, 2);\n        }\n        yield bot.lookAt(player.position);\n        if (yield discard(bot, itemType, num)) {\n            let given = false;\n            bot.once("playerCollect", (collector, collected) => {\n                console.log(collected.name);\n                if (collector.username === username) {\n                    log(bot, `${username} received ${itemType}.`);\n                    given = true;\n                }\n            });\n            let start = Date.now();\n            while (!given && !bot.interrupt_code) {\n                yield new Promise((resolve) => setTimeout(resolve, 500));\n                if (given) {\n                    return true;\n                }\n                if (Date.now() - start > 3000) {\n                    break;\n                }\n            }\n        }\n        log(bot, `Failed to give ${itemType} to ${username}, it was never received.`);\n        return false;\n    });\n}'}, 'goToBed': {'description': 'function goToBed(bot) {\n    return __awaiter(this, void 0, void 0, function* () {\n        /**\n         * Sleep in the nearest bed.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @returns {Promise<boolean>} true if the bed was found, false otherwise.\n         * @example\n         * await skills.goToBed(bot);\n         **/\n        const beds = bot.findBlocks({\n            matching: (block) => {\n                return block.name.includes("bed");\n            },\n            maxDistance: 32,\n            count: 1,\n        });\n        if (beds.length === 0) {\n            log(bot, `Could not find a bed to sleep in.`);\n            return false;\n        }\n        let loc = beds[0];\n        yield goToPosition(bot, loc.x, loc.y, loc.z);\n        const bed = bot.blockAt(loc);\n        yield bot.sleep(bed);\n        log(bot, `You are in bed.`);\n        bot.modes.pause("unstuck");\n        while (bot.isSleeping) {\n            yield new Promise((resolve) => setTimeout(resolve, 500));\n        }\n        log(bot, `You have woken up.`);\n        return true;\n    });\n}'}, 'goToNearestBlock': {'description': 'function goToNearestBlock(bot_1, blockType_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, blockType, min_distance = 2, range = 64) {\n        /**\n         * Navigate to the nearest block of the given type.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {string} blockType, the type of block to navigate to.\n         * @param {number} min_distance, the distance to keep from the block. Defaults to 2.\n         * @param {number} range, the range to look for the block. Defaults to 64.\n         * @returns {Promise<boolean>} true if the block was reached, false otherwise.\n         * @example\n         * await skills.goToNearestBlock(bot, "oak_log", 64, 2);\n         * **/\n        const MAX_RANGE = 512;\n        if (range > MAX_RANGE) {\n            log(bot, `Maximum search range capped at ${MAX_RANGE}. `);\n            range = MAX_RANGE;\n        }\n        let block = world.getNearestBlock(bot, blockType, range);\n        if (!block) {\n            log(bot, `Could not find any ${blockType} in ${range} blocks.`);\n            return false;\n        }\n        log(bot, `Found ${blockType} at ${block.position}.`);\n        yield goToPosition(bot, block.position.x, block.position.y, block.position.z, min_distance);\n        return true;\n    });\n}'}, 'goToNearestEntity': {'description': 'function goToNearestEntity(bot_1, entityType_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, entityType, min_distance = 2, range = 64) {\n        /**\n         * Navigate to the nearest entity of the given type.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {string} entityType, the type of entity to navigate to.\n         * @param {number} min_distance, the distance to keep from the entity. Defaults to 2.\n         * @param {number} range, the range to look for the entity. Defaults to 64.\n         * @returns {Promise<boolean>} true if the entity was reached, false otherwise.\n         **/\n        let entity = world.getNearestEntityWhere(bot, (entity) => entity.name === entityType, range);\n        if (!entity) {\n            log(bot, `Could not find any ${entityType} in ${range} blocks.`);\n            return false;\n        }\n        let distance = bot.entity.position.distanceTo(entity.position);\n        log(bot, `Found ${entityType} ${distance} blocks away.`);\n        yield goToPosition(bot, entity.position.x, entity.position.y, entity.position.z, min_distance);\n        return true;\n    });\n}'}, 'goToPlayer': {'description': 'function goToPlayer(bot_1, username_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, username, distance = 3) {\n        /**\n         * Navigate to the given player.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {string} username, the username of the player to navigate to.\n         * @param {number} distance, the goal distance to the player.\n         * @returns {Promise<boolean>} true if the player was found, false otherwise.\n         * @example\n         * await skills.goToPlayer(bot, "player");\n         **/\n        if (bot.modes.isOn("cheat")) {\n            bot.chat("/tp @s " + username);\n            log(bot, `Teleported to ${username}.`);\n            return true;\n        }\n        bot.modes.pause("self_defense");\n        bot.modes.pause("cowardice");\n        let player = bot.players[username].entity;\n        if (!player) {\n            log(bot, `Could not find ${username}.`);\n            return false;\n        }\n        const move = new pf.Movements(bot);\n        bot.pathfinder.setMovements(move);\n        yield bot.pathfinder.goto(new pf.goals.GoalFollow(player, distance), true);\n        log(bot, `You have reached ${username}.`);\n    });\n}'}, 'goToPosition': {'description': 'function goToPosition(bot_1, x_1, y_1, z_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, x, y, z, min_distance = 2) {\n        /**\n         * Navigate to the given position.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {number} x, the x coordinate to navigate to. If null, the bot\'s current x coordinate will be used.\n         * @param {number} y, the y coordinate to navigate to. If null, the bot\'s current y coordinate will be used.\n         * @param {number} z, the z coordinate to navigate to. If null, the bot\'s current z coordinate will be used.\n         * @param {number} distance, the distance to keep from the position. Defaults to 2.\n         * @returns {Promise<boolean>} true if the position was reached, false otherwise.\n         * @example\n         * let position = world.world.getNearestBlock(bot, "oak_log", 64).position;\n         * await skills.goToPosition(bot, position.x, position.y, position.x + 20);\n         **/\n        if (x == null || y == null || z == null) {\n            log(bot, `Missing coordinates, given x:${x} y:${y} z:${z}`);\n            return false;\n        }\n        if (bot.modes.isOn("cheat")) {\n            bot.chat("/tp @s " + x + " " + y + " " + z);\n            log(bot, `Teleported to ${x}, ${y}, ${z}.`);\n            return true;\n        }\n        bot.pathfinder.setMovements(new pf.Movements(bot));\n        yield bot.pathfinder.goto(new pf.goals.GoalNear(x, y, z, min_distance));\n        log(bot, `You have reached at ${x}, ${y}, ${z}.`);\n        return true;\n    });\n}'}, 'log': {'description': 'function log(bot, message) {\n    bot.output += message + "\\n";\n}'}, 'moveAway': {'description': 'function moveAway(bot, distance) {\n    return __awaiter(this, void 0, void 0, function* () {\n        /**\n         * Move away from current position in any direction.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {number} distance, the distance to move away.\n         * @returns {Promise<boolean>} true if the bot moved away, false otherwise.\n         * @example\n         * await skills.moveAway(bot, 8);\n         **/\n        const pos = bot.entity.position;\n        let goal = new pf.goals.GoalNear(pos.x, pos.y, pos.z, distance);\n        let inverted_goal = new pf.goals.GoalInvert(goal);\n        bot.pathfinder.setMovements(new pf.Movements(bot));\n        if (bot.modes.isOn("cheat")) {\n            const move = new pf.Movements(bot);\n            const path = yield bot.pathfinder.getPathTo(move, inverted_goal, 10000);\n            let last_move = path.path[path.path.length - 1];\n            console.log(last_move);\n            if (last_move) {\n                let x = Math.floor(last_move.x);\n                let y = Math.floor(last_move.y);\n                let z = Math.floor(last_move.z);\n                bot.chat("/tp @s " + x + " " + y + " " + z);\n                return true;\n            }\n        }\n        yield bot.pathfinder.goto(inverted_goal);\n        let new_pos = bot.entity.position;\n        log(bot, `Moved away from nearest entity to ${new_pos}.`);\n        return true;\n    });\n}'}, 'moveAwayFromEntity': {'description': 'function moveAwayFromEntity(bot_1, entity_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, entity, distance = 16) {\n        /**\n         * Move away from the given entity.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {Entity} entity, the entity to move away from.\n         * @param {number} distance, the distance to move away.\n         * @returns {Promise<boolean>} true if the bot moved away, false otherwise.\n         **/\n        let goal = new pf.goals.GoalFollow(entity, distance);\n        let inverted_goal = new pf.goals.GoalInvert(goal);\n        bot.pathfinder.setMovements(new pf.Movements(bot));\n        yield bot.pathfinder.goto(inverted_goal);\n        return true;\n    });\n}'}, 'pickupNearbyItems': {'description': 'function pickupNearbyItems(bot) {\n    return __awaiter(this, void 0, void 0, function* () {\n        /**\n         * Pick up all nearby items.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @returns {Promise<boolean>} true if the items were picked up, false otherwise.\n         * @example\n         * await skills.pickupNearbyItems(bot);\n         **/\n        const distance = 8;\n        const getNearestItem = (bot) => bot.nearestEntity((entity) => entity.name === "item" &&\n            bot.entity.position.distanceTo(entity.position) < distance);\n        let nearestItem = getNearestItem(bot);\n        let pickedUp = 0;\n        while (nearestItem) {\n            bot.pathfinder.setMovements(new pf.Movements(bot));\n            yield bot.pathfinder.goto(new pf.goals.GoalFollow(nearestItem, 0.8), true);\n            yield new Promise((resolve) => setTimeout(resolve, 200));\n            let prev = nearestItem;\n            nearestItem = getNearestItem(bot);\n            if (prev === nearestItem) {\n                break;\n            }\n            pickedUp++;\n        }\n        log(bot, `Picked up ${pickedUp} items.`);\n        return true;\n    });\n}'}, 'placeBlock': {'description': 'function placeBlock(bot_1, blockType_1, x_1, y_1, z_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, blockType, x, y, z, placeOn = "bottom", dontCheat = false) {\n        /**\n         * Place the given block type at the given position. It will build off from any adjacent blocks. Will fail if there is a block in the way or nothing to build off of.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {string} blockType, the type of block to place.\n         * @param {number} x, the x coordinate of the block to place.\n         * @param {number} y, the y coordinate of the block to place.\n         * @param {number} z, the z coordinate of the block to place.\n         * @param {string} placeOn, the preferred side of the block to place on. Can be \'top\', \'bottom\', \'north\', \'south\', \'east\', \'west\', or \'side\'. Defaults to bottom. Will place on first available side if not possible.\n         * @param {boolean} dontCheat, overrides cheat mode to place the block normally. Defaults to false.\n         * @returns {Promise<boolean>} true if the block was placed, false otherwise.\n         * @example\n         * let p = world.getPosition(bot);\n         * await skills.placeBlock(bot, "oak_log", p.x + 2, p.y, p.x);\n         * await skills.placeBlock(bot, "torch", p.x + 1, p.y, p.x, \'side\');\n         **/\n        console.log("placing block", blockType, x, y, z, placeOn, dontCheat);\n        if (!mc.getBlockId(blockType)) {\n            log(bot, `Invalid block type: ${blockType}.`);\n            return false;\n        }\n        const target_dest = new Vec3(Math.floor(x), Math.floor(y), Math.floor(z));\n        if (bot.modes.isOn("cheat") && !dontCheat) {\n            // invert the facing direction\n            let face = placeOn === "north"\n                ? "south"\n                : placeOn === "south"\n                    ? "north"\n                    : placeOn === "east"\n                        ? "west"\n                        : "east";\n            if (blockType.includes("torch") && placeOn !== "bottom") {\n                // insert wall_ before torch\n                blockType = blockType.replace("torch", "wall_torch");\n                if (placeOn !== "side" && placeOn !== "top") {\n                    blockType += `[facing=${face}]`;\n                }\n            }\n            if (blockType.includes("button") || blockType === "lever") {\n                if (placeOn === "top") {\n                    blockType += `[face=ceiling]`;\n                }\n                else if (placeOn === "bottom") {\n                    blockType += `[face=floor]`;\n                }\n                else {\n                    blockType += `[facing=${face}]`;\n                }\n            }\n            if (blockType === "ladder" ||\n                blockType === "repeater" ||\n                blockType === "comparator") {\n                blockType += `[facing=${face}]`;\n            }\n            if (blockType.includes("stairs")) {\n                blockType += `[facing=${face}]`;\n            }\n            let msg = "/setblock " +\n                Math.floor(x) +\n                " " +\n                Math.floor(y) +\n                " " +\n                Math.floor(z) +\n                " " +\n                blockType;\n            console.log("msg", msg);\n            bot.chat(msg);\n            if (blockType.includes("door"))\n                bot.chat("/setblock " +\n                    Math.floor(x) +\n                    " " +\n                    Math.floor(y + 1) +\n                    " " +\n                    Math.floor(z) +\n                    " " +\n                    blockType +\n                    "[half=upper]");\n            if (blockType.includes("bed"))\n                bot.chat("/setblock " +\n                    Math.floor(x) +\n                    " " +\n                    Math.floor(y) +\n                    " " +\n                    Math.floor(z - 1) +\n                    " " +\n                    blockType +\n                    "[part=head]");\n            log(bot, `Used /setblock to place ${blockType} at ${target_dest}.`);\n            return true;\n        }\n        let item_name = blockType;\n        if (item_name == "redstone_wire")\n            item_name = "redstone";\n        let block = bot.inventory\n            .items()\n            .find((item) => item.name === item_name);\n        if (!block && bot.game.gameMode === "creative") {\n            yield bot.creative.setInventorySlot(36, mc.makeItem(item_name, 1)); // 36 is first hotbar slot\n            block = bot.inventory.items().find((item) => item.name === item_name);\n        }\n        if (!block) {\n            log(bot, `Don\'t have any ${blockType} to place.`);\n            return false;\n        }\n        const targetBlock = bot.blockAt(target_dest);\n        if (targetBlock.name === blockType) {\n            log(bot, `${blockType} already at ${targetBlock.position}.`);\n            return false;\n        }\n        const empty_blocks = [\n            "air",\n            "water",\n            "lava",\n            "grass",\n            "short_grass",\n            "tall_grass",\n            "snow",\n            "dead_bush",\n            "fern",\n        ];\n        if (!empty_blocks.includes(targetBlock.name)) {\n            log(bot, `${blockType} in the way at ${targetBlock.position}.`);\n            const removed = yield breakBlockAt(bot, x, y, z);\n            if (!removed) {\n                log(bot, `Cannot place ${blockType} at ${targetBlock.position}: block in the way.`);\n                return false;\n            }\n            yield new Promise((resolve) => setTimeout(resolve, 200)); // wait for block to break\n        }\n        // get the buildoffblock and facevec based on whichever adjacent block is not empty\n        let buildOffBlock = null;\n        let faceVec = null;\n        const dir_map = {\n            top: new Vec3(0, 1, 0),\n            bottom: new Vec3(0, -1, 0),\n            north: new Vec3(0, 0, -1),\n            south: new Vec3(0, 0, 1),\n            east: new Vec3(1, 0, 0),\n            west: new Vec3(-1, 0, 0),\n        };\n        let dirs = [];\n        if (placeOn === "side") {\n            dirs.push(dir_map["north"], dir_map["south"], dir_map["east"], dir_map["west"]);\n        }\n        else if (dir_map[placeOn] !== undefined) {\n            dirs.push(dir_map[placeOn]);\n        }\n        else {\n            dirs.push(dir_map["bottom"]);\n            log(bot, `Unknown placeOn value "${placeOn}". Defaulting to bottom.`);\n        }\n        dirs.push(...Object.values(dir_map).filter((d) => !dirs.includes(d)));\n        for (let d of dirs) {\n            const block = bot.blockAt(target_dest.plus(d));\n            if (!empty_blocks.includes(block.name)) {\n                buildOffBlock = block;\n                faceVec = new Vec3(-d.x, -d.y, -d.z); // invert\n                break;\n            }\n        }\n        if (!buildOffBlock) {\n            log(bot, `Cannot place ${blockType} at ${targetBlock.position}: nothing to place on.`);\n            return false;\n        }\n        const pos = bot.entity.position;\n        const pos_above = pos.plus(new Vec3(0, 1, 0));\n        const dont_move_for = [\n            "torch",\n            "redstone_torch",\n            "redstone_wire",\n            "lever",\n            "button",\n            "rail",\n            "detector_rail",\n            "powered_rail",\n            "activator_rail",\n            "tripwire_hook",\n            "tripwire",\n            "water_bucket",\n        ];\n        if (!dont_move_for.includes(blockType) &&\n            (pos.distanceTo(targetBlock.position) < 1 ||\n                pos_above.distanceTo(targetBlock.position) < 1)) {\n            // too close\n            let goal = new pf.goals.GoalNear(targetBlock.position.x, targetBlock.position.y, targetBlock.position.z, 2);\n            let inverted_goal = new pf.goals.GoalInvert(goal);\n            bot.pathfinder.setMovements(new pf.Movements(bot));\n            yield bot.pathfinder.goto(inverted_goal);\n        }\n        if (bot.entity.position.distanceTo(targetBlock.position) > 4.5) {\n            // too far\n            let pos = targetBlock.position;\n            let movements = new pf.Movements(bot);\n            bot.pathfinder.setMovements(movements);\n            yield bot.pathfinder.goto(new pf.goals.GoalNear(pos.x, pos.y, pos.z, 4));\n        }\n        yield bot.equip(block, "hand");\n        yield bot.lookAt(buildOffBlock.position);\n        // will throw error if an entity is in the way, and sometimes even if the block was placed\n        try {\n            yield bot.placeBlock(buildOffBlock, faceVec);\n            log(bot, `Placed ${blockType} at ${target_dest}.`);\n            yield new Promise((resolve) => setTimeout(resolve, 200));\n            return true;\n        }\n        catch (err) {\n            log(bot, `Failed to place ${blockType} at ${target_dest}.`);\n            return false;\n        }\n    });\n}'}, 'putInChest': {'description': 'function putInChest(bot_1, itemName_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, itemName, num = -1) {\n        /**\n         * Put the given item in the nearest chest.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {string} itemName, the item or block name to put in the chest.\n         * @param {number} num, the number of items to put in the chest. Defaults to -1, which puts all items.\n         * @returns {Promise<boolean>} true if the item was put in the chest, false otherwise.\n         * @example\n         * await skills.putInChest(bot, "oak_log");\n         **/\n        let chest = world.getNearestBlock(bot, "chest", 32);\n        if (!chest) {\n            log(bot, `Could not find a chest nearby.`);\n            return false;\n        }\n        let item = bot.inventory.items().find((item) => item.name === itemName);\n        if (!item) {\n            log(bot, `You do not have any ${itemName} to put in the chest.`);\n            return false;\n        }\n        let to_put = num === -1 ? item.count : Math.min(num, item.count);\n        yield goToPosition(bot, chest.position.x, chest.position.y, chest.position.z, 2);\n        const chestContainer = yield bot.openContainer(chest);\n        yield chestContainer.deposit(item.type, null, to_put);\n        yield chestContainer.close();\n        log(bot, `Successfully put ${to_put} ${itemName} in the chest.`);\n        return true;\n    });\n}'}, 'smeltItem': {'description': 'function smeltItem(bot_1, itemName_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, itemName, num = 1) {\n        /**\n         * Puts 1 coal in furnace and smelts the given item name, waits until the furnace runs out of fuel or input items.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {string} itemName, the item name to smelt. Ores must contain "raw" like raw_iron.\n         * @param {number} num, the number of items to smelt. Defaults to 1.\n         * @returns {Promise<boolean>} true if the item was smelted, false otherwise. Fail\n         * @example\n         * await skills.smeltItem(bot, "raw_iron");\n         * await skills.smeltItem(bot, "beef");\n         **/\n        if (!mc.isSmeltable(itemName)) {\n            log(bot, `Cannot smelt ${itemName}. Hint: make sure you are smelting the \'raw\' item.`);\n            return false;\n        }\n        let placedFurnace = false;\n        let furnaceBlock = undefined;\n        const furnaceRange = 32;\n        furnaceBlock = world.getNearestBlock(bot, "furnace", furnaceRange);\n        if (!furnaceBlock) {\n            // Try to place furnace\n            let hasFurnace = world.getInventoryCounts(bot)["furnace"] > 0;\n            if (hasFurnace) {\n                let pos = world.getNearestFreeSpace(bot, 1, furnaceRange);\n                yield placeBlock(bot, "furnace", pos.x, pos.y, pos.z);\n                furnaceBlock = world.getNearestBlock(bot, "furnace", furnaceRange);\n                placedFurnace = true;\n            }\n        }\n        if (!furnaceBlock) {\n            log(bot, `There is no furnace nearby and you have no furnace.`);\n            return false;\n        }\n        if (bot.entity.position.distanceTo(furnaceBlock.position) > 4) {\n            yield goToNearestBlock(bot, "furnace", 4, furnaceRange);\n        }\n        bot.modes.pause("unstuck");\n        yield bot.lookAt(furnaceBlock.position);\n        console.log("smelting...");\n        const furnace = yield bot.openFurnace(furnaceBlock);\n        // check if the furnace is already smelting something\n        let input_item = furnace.inputItem();\n        if (input_item &&\n            input_item.type !== mc.getItemId(itemName) &&\n            input_item.count > 0) {\n            // TODO: check if furnace is currently burning fuel. furnace.fuel is always null, I think there is a bug.\n            // This only checks if the furnace has an input item, but it may not be smelting it and should be cleared.\n            log(bot, `The furnace is currently smelting ${mc.getItemName(input_item.type)}.`);\n            if (placedFurnace)\n                yield collectBlock(bot, "furnace", 1);\n            return false;\n        }\n        // check if the bot has enough items to smelt\n        let inv_counts = world.getInventoryCounts(bot);\n        if (!inv_counts[itemName] || inv_counts[itemName] < num) {\n            log(bot, `You do not have enough ${itemName} to smelt.`);\n            if (placedFurnace)\n                yield collectBlock(bot, "furnace", 1);\n            return false;\n        }\n        // fuel the furnace\n        if (!furnace.fuelItem()) {\n            let fuel = mc.getSmeltingFuel(bot);\n            if (!fuel) {\n                log(bot, `You have no fuel to smelt ${itemName}, you need coal, charcoal, or wood.`);\n                if (placedFurnace)\n                    yield collectBlock(bot, "furnace", 1);\n                return false;\n            }\n            log(bot, `Using ${fuel.name} as fuel.`);\n            const put_fuel = Math.ceil(num / mc.getFuelSmeltOutput(fuel.name));\n            if (fuel.count < put_fuel) {\n                log(bot, `You don\'t have enough ${fuel.name} to smelt ${num} ${itemName}; you need ${put_fuel}.`);\n                if (placedFurnace)\n                    yield collectBlock(bot, "furnace", 1);\n                return false;\n            }\n            yield furnace.putFuel(fuel.type, null, put_fuel);\n            log(bot, `Added ${put_fuel} ${mc.getItemName(fuel.type)} to furnace fuel.`);\n            console.log(`Added ${put_fuel} ${mc.getItemName(fuel.type)} to furnace fuel.`);\n        }\n        // put the items in the furnace\n        yield furnace.putInput(mc.getItemId(itemName), null, num);\n        // wait for the items to smelt\n        let total = 0;\n        let collected_last = true;\n        let smelted_item = null;\n        yield new Promise((resolve) => setTimeout(resolve, 200));\n        while (total < num) {\n            yield new Promise((resolve) => setTimeout(resolve, 10000));\n            console.log("checking...");\n            let collected = false;\n            if (furnace.outputItem()) {\n                smelted_item = yield furnace.takeOutput();\n                if (smelted_item) {\n                    total += smelted_item.count;\n                    collected = true;\n                }\n            }\n            if (!collected && !collected_last) {\n                break; // if nothing was collected this time or last time\n            }\n            collected_last = collected;\n            if (bot.interrupt_code) {\n                break;\n            }\n        }\n        yield bot.closeWindow(furnace);\n        if (placedFurnace) {\n            yield collectBlock(bot, "furnace", 1);\n        }\n        if (total === 0) {\n            log(bot, `Failed to smelt ${itemName}.`);\n            return false;\n        }\n        if (total < num) {\n            log(bot, `Only smelted ${total} ${mc.getItemName(smelted_item.type)}.`);\n            return false;\n        }\n        log(bot, `Successfully smelted ${itemName}, got ${total} ${mc.getItemName(smelted_item.type)}.`);\n        return true;\n    });\n}'}, 'stay': {'description': 'function stay(bot_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, seconds = 30) {\n        /**\n         * Stay in the current position until interrupted. Disables all modes.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {number} seconds, the number of seconds to stay. Defaults to 30. -1 for indefinite.\n         * @returns {Promise<boolean>} true if the bot stayed, false otherwise.\n         * @example\n         * await skills.stay(bot);\n         **/\n        bot.modes.pause("self_preservation");\n        bot.modes.pause("unstuck");\n        bot.modes.pause("cowardice");\n        bot.modes.pause("self_defense");\n        bot.modes.pause("hunting");\n        bot.modes.pause("torch_placing");\n        bot.modes.pause("item_collecting");\n        let start = Date.now();\n        while (!bot.interrupt_code &&\n            (seconds === -1 || Date.now() - start < seconds * 1000)) {\n            yield new Promise((resolve) => setTimeout(resolve, 500));\n        }\n        log(bot, `Stayed for ${(Date.now() - start) / 1000} seconds.`);\n        return true;\n    });\n}'}, 'summonMobType': {'description': 'function summonMobType(bot_1, mobType_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, mobType, num = 1) {\n        /**\n         * Summon mobs of the given type.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {string} mobType, the type of mob to summon.\n         * @param {number} num, the number of mobs to summon. Defaults to 1.\n         * @returns {Promise<boolean>} true if the mobs were summoned, false if the mob type was not found.\n         * @example\n         * await skills.summonMobType(bot, "zombie", 10);\n         **/\n        for (let i = 0; i < num; i++) {\n            yield bot.chat("/summon " + mobType);\n        }\n        return true;\n    });\n}'}, 'takeFromChest': {'description': 'function takeFromChest(bot_1, itemName_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, itemName, num = -1) {\n        /**\n         * Take the given item from the nearest chest.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {string} itemName, the item or block name to take from the chest.\n         * @param {number} num, the number of items to take from the chest. Defaults to -1, which takes all items.\n         * @returns {Promise<boolean>} true if the item was taken from the chest, false otherwise.\n         * @example\n         * await skills.takeFromChest(bot, "oak_log");\n         * **/\n        let chest = world.getNearestBlock(bot, "chest", 32);\n        if (!chest) {\n            log(bot, `Could not find a chest nearby.`);\n            return false;\n        }\n        yield goToPosition(bot, chest.position.x, chest.position.y, chest.position.z, 2);\n        const chestContainer = yield bot.openContainer(chest);\n        let item = chestContainer\n            .containerItems()\n            .find((item) => item.name === itemName);\n        if (!item) {\n            log(bot, `Could not find any ${itemName} in the chest.`);\n            yield chestContainer.close();\n            return false;\n        }\n        let to_take = num === -1 ? item.count : Math.min(num, item.count);\n        yield chestContainer.withdraw(item.type, null, to_take);\n        yield chestContainer.close();\n        log(bot, `Successfully took ${to_take} ${itemName} from the chest.`);\n        return true;\n    });\n}'}, 'tillAndSow': {'description': 'function tillAndSow(bot_1, x_1, y_1, z_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, x, y, z, seedType = null) {\n        /**\n         * Till the ground at the given position and plant the given seed type.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {number} x, the x coordinate to till.\n         * @param {number} y, the y coordinate to till.\n         * @param {number} z, the z coordinate to till.\n         * @param {string} plantType, the type of plant to plant. Defaults to none, which will only till the ground.\n         * @returns {Promise<boolean>} true if the ground was tilled, false otherwise.\n         * @example\n         * let position = world.getPosition(bot);\n         * await skills.till(bot, position.x, position.y - 1, position.x);\n         **/\n        console.log(x, y, z);\n        x = Math.round(x);\n        y = Math.round(y);\n        z = Math.round(z);\n        let block = bot.blockAt(new Vec3(x, y, z));\n        console.log(x, y, z);\n        if (block.name !== "grass_block" &&\n            block.name !== "dirt" &&\n            block.name !== "farmland") {\n            log(bot, `Cannot till ${block.name}, must be grass_block or dirt.`);\n            return false;\n        }\n        let above = bot.blockAt(new Vec3(x, y + 1, z));\n        if (above.name !== "air") {\n            log(bot, `Cannot till, there is ${above.name} above the block.`);\n            return false;\n        }\n        // if distance is too far, move to the block\n        if (bot.entity.position.distanceTo(block.position) > 4.5) {\n            let pos = block.position;\n            bot.pathfinder.setMovements(new pf.Movements(bot));\n            yield bot.pathfinder.goto(new pf.goals.GoalNear(pos.x, pos.y, pos.z, 4));\n        }\n        if (block.name !== "farmland") {\n            let hoe = bot.inventory\n                .items()\n                .find((item) => item.name.includes("hoe"));\n            if (!hoe) {\n                log(bot, `Cannot till, no hoes.`);\n                return false;\n            }\n            yield bot.equip(hoe, "hand");\n            yield bot.activateBlock(block);\n            log(bot, `Tilled block x:${x.toFixed(1)}, y:${y.toFixed(1)}, z:${z.toFixed(1)}.`);\n        }\n        if (seedType) {\n            if (seedType.endsWith("seed") && !seedType.endsWith("seeds"))\n                seedType += "s"; // fixes common mistake\n            let seeds = bot.inventory\n                .items()\n                .find((item) => item.name === seedType);\n            if (!seeds) {\n                log(bot, `No ${seedType} to plant.`);\n                return false;\n            }\n            yield bot.equip(seeds, "hand");\n            yield bot.placeBlock(block, new Vec3(0, -1, 0));\n            log(bot, `Planted ${seedType} at x:${x.toFixed(1)}, y:${y.toFixed(1)}, z:${z.toFixed(1)}.`);\n        }\n        return true;\n    });\n}'}, 'useDoor': {'description': 'function useDoor(bot_1) {\n    return __awaiter(this, arguments, void 0, function* (bot, door_pos = null) {\n        /**\n         * Use the door at the given position.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @param {Vec3} door_pos, the position of the door to use. If null, the nearest door will be used.\n         * @returns {Promise<boolean>} true if the door was used, false otherwise.\n         * @example\n         * let door = world.getNearestBlock(bot, "oak_door", 16).position;\n         * await skills.useDoor(bot, door);\n         **/\n        if (!door_pos) {\n            for (let door_type of [\n                "oak_door",\n                "spruce_door",\n                "birch_door",\n                "jungle_door",\n                "acacia_door",\n                "dark_oak_door",\n                "mangrove_door",\n                "cherry_door",\n                "bamboo_door",\n                "crimson_door",\n                "warped_door",\n            ]) {\n                door_pos = world.getNearestBlock(bot, door_type, 16).position;\n                if (door_pos)\n                    break;\n            }\n        }\n        else {\n            door_pos = new Vec3(door_pos.x, door_pos.y, door_pos.z);\n        }\n        if (!door_pos) {\n            log(bot, `Could not find a door to use.`);\n            return false;\n        }\n        bot.pathfinder.setGoal(new pf.goals.GoalNear(door_pos.x, door_pos.y, door_pos.z, 1));\n        yield new Promise((resolve) => setTimeout(resolve, 1000));\n        while (bot.pathfinder.isMoving()) {\n            yield new Promise((resolve) => setTimeout(resolve, 100));\n        }\n        let door_block = bot.blockAt(door_pos);\n        yield bot.lookAt(door_pos);\n        if (!door_block._properties.open)\n            yield bot.activateBlock(door_block);\n        bot.setControlState("forward", true);\n        yield new Promise((resolve) => setTimeout(resolve, 600));\n        bot.setControlState("forward", false);\n        yield bot.activateBlock(door_block);\n        log(bot, `Used door at ${door_pos}.`);\n        return true;\n    });\n}'}, 'viewChest': {'description': 'function viewChest(bot) {\n    return __awaiter(this, void 0, void 0, function* () {\n        /**\n         * View the contents of the nearest chest.\n         * @param {MinecraftBot} bot, reference to the minecraft bot.\n         * @returns {Promise<boolean>} true if the chest was viewed, false otherwise.\n         * @example\n         * await skills.viewChest(bot);\n         * **/\n        let chest = world.getNearestBlock(bot, "chest", 32);\n        if (!chest) {\n            log(bot, `Could not find a chest nearby.`);\n            return false;\n        }\n        yield goToPosition(bot, chest.position.x, chest.position.y, chest.position.z, 2);\n        const chestContainer = yield bot.openContainer(chest);\n        let items = chestContainer.containerItems();\n        if (items.length === 0) {\n            log(bot, `The chest is empty.`);\n        }\n        else {\n            log(bot, `The chest contains:`);\n            for (let item of items) {\n                log(bot, `${item.count} ${item.name}`);\n            }\n        }\n        yield chestContainer.close();\n        return true;\n    });\n}'}}, 'world': {'getBiomeName': {'description': 'function getBiomeName(bot) {\n    /**\n     * Get the name of the biome the bot is in.\n     * @param {Bot} bot - The bot to get the biome for.\n     * @returns {string} - The name of the biome.\n     * @example\n     * let biome = world.getBiomeName(bot);\n     **/\n    const biomeId = bot.world.getBiome(bot.entity.position);\n    return mc.getAllBiomes()[biomeId].name;\n}'}, 'getCraftableItems': {'description': 'function getCraftableItems(bot) {\n    /**\n     * Get a list of all items that can be crafted with the bot\'s current inventory.\n     * @param {Bot} bot - The bot to get the craftable items for.\n     * @returns {string[]} - A list of all items that can be crafted.\n     * @example\n     * let craftableItems = world.getCraftableItems(bot);\n     **/\n    let table = getNearestBlock(bot, "crafting_table");\n    if (!table) {\n        for (const item of bot.inventory.items()) {\n            if (item != null && item.name === "crafting_table") {\n                table = item;\n                break;\n            }\n        }\n    }\n    let res = [];\n    for (const item of mc.getAllItems()) {\n        let recipes = bot.recipesFor(item.id, null, 1, table);\n        if (recipes.length > 0)\n            res.push(item.name);\n    }\n    return res;\n}'}, 'getInventoryCounts': {'description': "function getInventoryCounts(bot) {\n    /**\n     * Get an object representing the bot's inventory.\n     * @param {Bot} bot - The bot to get the inventory for.\n     * @returns {object} - An object with item names as keys and counts as values.\n     * @example\n     * let inventory = world.getInventoryCounts(bot);\n     * let oakLogCount = inventory['oak_log'];\n     * let hasWoodenPickaxe = inventory['wooden_pickaxe'] > 0;\n     **/\n    let inventory = {};\n    for (const item of bot.inventory.items()) {\n        if (item != null) {\n            if (inventory[item.name] == null) {\n                inventory[item.name] = 0;\n            }\n            inventory[item.name] += item.count;\n        }\n    }\n    return inventory;\n}"}, 'getInventoryStacks': {'description': 'function getInventoryStacks(bot) {\n    let inventory = [];\n    for (const item of bot.inventory.items()) {\n        if (item != null) {\n            inventory.push(item);\n        }\n    }\n    return inventory;\n}'}, 'getNearbyBlockTypes': {'description': 'function getNearbyBlockTypes(bot, distance = 16) {\n    /**\n     * Get a list of all nearby block names.\n     * @param {Bot} bot - The bot to get nearby blocks for.\n     * @param {number} distance - The maximum distance to search, default 16.\n     * @returns {string[]} - A list of all nearby blocks.\n     * @example\n     * let blocks = world.getNearbyBlockTypes(bot);\n     **/\n    let blocks = getNearestBlocks(bot, null, distance);\n    let found = [];\n    for (let i = 0; i < blocks.length; i++) {\n        if (blocks[i].name && !found.includes(blocks[i].name)) {\n            found.push(blocks[i].name);\n        }\n    }\n    return found;\n}'}, 'getNearbyEntities': {'description': 'function getNearbyEntities(bot, maxDistance = 16) {\n    let entities = [];\n    for (const entity of Object.values(bot.entities)) {\n        const distance = entity.position.distanceTo(bot.entity.position);\n        if (distance > maxDistance)\n            continue;\n        entities.push({ entity, distance });\n    }\n    entities.sort((a, b) => a.distance - b.distance);\n    let res = [];\n    for (let i = 0; i < entities.length; i++) {\n        res.push(entities[i].entity);\n    }\n    return res;\n}'}, 'getNearbyEntityTypes': {'description': 'function getNearbyEntityTypes(bot) {\n    /**\n     * Get a list of all nearby mob types.\n     * @param {Bot} bot - The bot to get nearby mobs for.\n     * @returns {string[]} - A list of all nearby mobs.\n     * @example\n     * let mobs = world.getNearbyEntityTypes(bot);\n     **/\n    let mobs = getNearbyEntities(bot, 16);\n    let found = [];\n    for (let i = 0; i < mobs.length; i++) {\n        if (mobs[i].name && !found.includes(mobs[i].name)) {\n            found.push(mobs[i].name);\n        }\n    }\n    return found;\n}'}, 'getNearbyPlayerNames': {'description': 'function getNearbyPlayerNames(bot) {\n    /**\n     * Get a list of all nearby player names.\n     * @param {Bot} bot - The bot to get nearby players for.\n     * @returns {string[]} - A list of all nearby players.\n     * @example\n     * let players = world.getNearbyPlayerNames(bot);\n     **/\n    let players = getNearbyPlayers(bot, 64);\n    let found = [];\n    for (let i = 0; i < players.length; i++) {\n        if (players[i] &&\n            players[i].username &&\n            !found.includes(players[i].username) &&\n            players[i].username != bot.username) {\n            found.push(players[i].username);\n        }\n    }\n    return found;\n}'}, 'getNearbyPlayers': {'description': 'function getNearbyPlayers(bot, maxDistance = 16) {\n    if (maxDistance == null)\n        maxDistance = 16;\n    let players = [];\n    for (const entity of Object.values(bot.entities)) {\n        const distance = entity.position.distanceTo(bot.entity.position);\n        if (distance > maxDistance)\n            continue;\n        if (entity.type == "player" && entity.username != bot.username) {\n            players.push({ entity: entity, distance: distance });\n        }\n    }\n    players.sort((a, b) => a.distance - b.distance);\n    let res = [];\n    for (let i = 0; i < players.length; i++) {\n        res.push(players[i].entity);\n    }\n    return res;\n}'}, 'getNearestBlock': {'description': "function getNearestBlock(bot, block_type, distance = 16) {\n    /**\n     * Get the nearest block of the given type.\n     * @param {Bot} bot - The bot to get the nearest block for.\n     * @param {string} block_type - The name of the block to search for.\n     * @param {number} distance - The maximum distance to search, default 16.\n     * @returns {Block} - The nearest block of the given type.\n     * @example\n     * let coalBlock = world.getNearestBlock(bot, 'coal_ore', 16);\n     **/\n    let blocks = getNearestBlocks(bot, [block_type], distance, 1);\n    if (blocks.length > 0) {\n        return blocks[0];\n    }\n    return null;\n}"}, 'getNearestBlocks': {'description': 'function getNearestBlocks(bot, block_types = null, distance = 16, count = 10000) {\n    /**\n     * Get a list of the nearest blocks of the given types.\n     * @param {Bot} bot - The bot to get the nearest block for.\n     * @param {string[]} block_types - The names of the blocks to search for.\n     * @param {number} distance - The maximum distance to search, default 16.\n     * @param {number} count - The maximum number of blocks to find, default 10000.\n     * @returns {Block[]} - The nearest blocks of the given type.\n     * @example\n     * let woodBlocks = world.getNearestBlocks(bot, [\'oak_log\', \'birch_log\'], 16, 1);\n     **/\n    // if blocktypes is not a list, make it a list\n    let block_ids = [];\n    if (block_types === null) {\n        block_ids = mc.getAllBlockIds(["air"]);\n    }\n    else {\n        if (!Array.isArray(block_types))\n            block_types = [block_types];\n        for (let block_type of block_types) {\n            block_ids.push(mc.getBlockId(block_type));\n        }\n    }\n    let positions = bot.findBlocks({\n        matching: block_ids,\n        maxDistance: distance,\n        count: count,\n    });\n    let blocks = [];\n    for (let i = 0; i < positions.length; i++) {\n        let block = bot.blockAt(positions[i]);\n        let distance = positions[i].distanceTo(bot.entity.position);\n        blocks.push({ block: block, distance: distance });\n    }\n    blocks.sort((a, b) => a.distance - b.distance);\n    let res = [];\n    for (let i = 0; i < blocks.length; i++) {\n        res.push(blocks[i].block);\n    }\n    return res;\n}'}, 'getNearestEntityWhere': {'description': 'function getNearestEntityWhere(bot, predicate, maxDistance = 16) {\n    return bot.nearestEntity((entity) => predicate(entity) &&\n        bot.entity.position.distanceTo(entity.position) < maxDistance);\n}'}, 'getNearestFreeSpace': {'description': 'function getNearestFreeSpace(bot, size = 1, distance = 8) {\n    /**\n     * Get the nearest empty space with solid blocks beneath it of the given size.\n     * @param {Bot} bot - The bot to get the nearest free space for.\n     * @param {number} size - The (size x size) of the space to find, default 1.\n     * @param {number} distance - The maximum distance to search, default 8.\n     * @returns {Vec3} - The south west corner position of the nearest free space.\n     * @example\n     * let position = world.getNearestFreeSpace(bot, 1, 8);\n     **/\n    let empty_pos = bot.findBlocks({\n        matching: (block) => {\n            return block && block.name == "air";\n        },\n        maxDistance: distance,\n        count: 1000,\n    });\n    for (let i = 0; i < empty_pos.length; i++) {\n        let empty = true;\n        for (let x = 0; x < size; x++) {\n            for (let z = 0; z < size; z++) {\n                let top = bot.blockAt(empty_pos[i].offset(x, 0, z));\n                let bottom = bot.blockAt(empty_pos[i].offset(x, -1, z));\n                if (!top ||\n                    top.name != "air" ||\n                    !bottom ||\n                    bottom.drops.length == 0 ||\n                    !bottom.diggable) {\n                    empty = false;\n                    break;\n                }\n            }\n            if (!empty)\n                break;\n        }\n        if (empty) {\n            return empty_pos[i];\n        }\n    }\n}'}, 'getPosition': {'description': 'function getPosition(bot) {\n    /**\n     * Get your position in the world (Note that y is vertical).\n     * @param {Bot} bot - The bot to get the position for.\n     * @returns {Vec3} - An object with x, y, and x attributes representing the position of the bot.\n     * @example\n     * let position = world.getPosition(bot);\n     * let x = position.x;\n     **/\n    return bot.entity.position;\n}'}, 'isClearPath': {'description': 'function isClearPath(bot, target) {\n    return __awaiter(this, void 0, void 0, function* () {\n        /**\n         * Check if there is a path to the target that requires no digging or placing blocks.\n         * @param {Bot} bot - The bot to get the path for.\n         * @param {Entity} target - The target to path to.\n         * @returns {boolean} - True if there is a clear path, false otherwise.\n         */\n        let movements = new pf.Movements(bot);\n        movements.canDig = false;\n        //movements.canPlaceOn = false; // TODO: fix this\n        let goal = new pf.goals.GoalNear(target.position.x, target.position.y, target.position.z, 1);\n        let path = yield bot.pathfinder.getPathTo(movements, goal, 100);\n        return path.status === "success";\n    });\n}'}, 'shouldPlaceTorch': {'description': 'function shouldPlaceTorch(bot) {\n    if (!bot.modes.isOn("torch_placing") || bot.interrupt_code)\n        return false;\n    const pos = getPosition(bot);\n    // TODO: check light level instead of nearby torches, block.light is broken\n    let nearest_torch = getNearestBlock(bot, "torch", 6);\n    if (!nearest_torch)\n        nearest_torch = getNearestBlock(bot, "wall_torch", 6);\n    if (!nearest_torch) {\n        const block = bot.blockAt(pos);\n        let has_torch = bot.inventory\n            .items()\n            .find((item) => item.name === "torch");\n        return has_torch && (block === null || block === void 0 ? void 0 : block.name) === "air";\n    }\n    return false;\n}'}}}
} 

SAMPLE_EVENT_INITIAL_STATE = {
    'name': 'python1',
    'event': 'initial_state',
    'executing': False,
    'chat_messages': [],
    'past_observationid': None,
    'depth_action_counter': 0,
    'output': None,
    'position': {
        'x': 1052.5,
        'y': 5,
        'z': -599.5
    },
    'health': 10,
    'health_status': 'alive',
    'lives': 1,
    'hunger': 10,
    'biome': 'plains',
    'weather': 'clear',
    'time': 147,
    'timeOfDay': 'morning',
    'players': ['survivor1'],
    'inventory': {
        'iron_pickaxe': 1,
        'oak_planks': 64,
        'cobblestone': 128,
        'torch': 64
    },
    'blocks': [
        'grass_block',
        'dirt',
        'bedrock',
        'gold_block',
        'glowstone',
        'bricks',
        'stone',
        'sand',
        'oak_fence',
        'cobblestone',
        'chest',
        'oak_stairs'
    ],
    'entities': ['player'],
    'craftable': [
        'crafting_table',
        'oak_button',
        'oak_pressure_plate',
        'stick'
    ],
    'observationId': 'l5a0buwj5vl2qolcuwsv',
    'participantId': 'python1',
    'sessionId': '21b3f581-1447-465a-b6cc-f9f97654b9f9',
    'runId': '21b3f581-1447-465a-b6cc-f9f97654b9f9'
}

SAMPLE_EVENT_COMMAND_EXECUTED_ERROR = {
    'name': 'python1',
    'event': 'command_executed',
    'executing': False,
    'chat_messages': [],
    'past_observationid': 'l5a0buwj5vl2qolcuwsv',
    'depth_action_counter': 1,
    'output': 'error : ',
    'position': {
        'x': 1052.5,
        'y': 5,
        'z': -599.5
    },
    'health': 10,
    'health_status': 'alive',
    'lives': 1,
    'hunger': 10,
    'biome': 'plains',
    'weather': 'clear',
    'time': 707,
    'timeOfDay': 'morning',
    'players': ['survivor1'],
    'inventory': {
        'iron_pickaxe': 1,
        'oak_planks': 64,
        'cobblestone': 108,
        'torch': 64
    },
    'blocks': [
        'grass_block',
        'cobblestone', 
        'dirt',
        'bedrock',
        'gold_block',
        'glowstone',
        'bricks',
        'stone',
        'sand',
        'oak_fence',
        'chest',
        'oak_stairs'
    ],
    'entities': ['player'],
    'craftable': [
        'crafting_table',
        'oak_button',
        'oak_pressure_plate',
        'stick'
    ],
    'observationId': 'hsdoxdn6qfmhhcpg4djw',
    'participantId': 'python1',
    'sessionId': '21b3f581-1447-465a-b6cc-f9f97654b9f9',
    'runId': '21b3f581-1447-465a-b6cc-f9f97654b9f9'
}